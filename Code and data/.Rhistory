mymin2 = min(mynorm)
mymax2 = max(mynorm)
if (mymin2 < mymin) { mymin = mymin2 }
if (mymax2 >mymax) { mymax = mymax2 }
# make a red histogram of the forecast errors, with the normally distributed data overlaid:
mybins = seq(mymin, mymax, mybinsize)
hist(forecasterrors, col="red", freq=FALSE, breaks = mybins)
# freq = FALSE ensures the area under the histogram = 1
# generate normally distributed data with mean 0 and sd mysd
myhist = hist(mynorm, plot = FALSE, breaks = mybins)
# plot the normal curve as a blue line on top of the histogram of forecast errors
points(myhist$mids, myhist$density, type = "l", col = "blue", lwd = 2)
}
plotForecastErrors(rainTSforecast2$residuals)
# The distribution of forecast errors is roughly centred on zero
# Normally distributed, although slightly skewed to the right
# The Ljung-Box test showed there is little evidence of non-zero
# autocorrelations in samle forecast errors
# So simple exponential smoothing method provides an adequate predictive model
# 80% & 95% predictions intervals are probably valid
# 22.4.2 Additive model with a trend and NO seasonality ####
# Annual diameter of women's skirts at the hem, from 1886-1911
skirts = scan("http://robjhyndman.com/tsdldata/roberts/skirts.dat", skip=5)
ts.skirts = ts(skirts, start = c(1886))
plot.ts(ts.skirts)
skirtsTSforecast = HoltWinters(ts.skirts, gamma = FALSE)
plot(skirtsTSforecast)
skirtsForecast = forecast.HoltWinters(skirtsTSforecast, h = 19)
plot.forecast(skirtsForecast)
acf(skirtsForecast$residuals, lag.max = 20)
Box.test(skirtsForecast$residuals, lag=20, type="Ljung-Box")
plot.ts(skirtsForecast$residuals)
plotForecastErrors(skirtsForecast$residuals)
# 22.4.3 Additive model WITH a +/- trend AND seasonality ####
# Monthly sales for a souvenir shop at a beach resort town
# in Queensland, Australia, for Jan 1987 - Dec 1993
souvenir = scan("http://robjhyndman.com/tsdldata/data/fancy.dat")
souvenirTS = ts(souvenir, frequency = 12, start = c(1987,1))
souvenirTS
logsouvenirTS = log(souvenirTS)
plot(ar(logsouvenirTS))
souvenirTSforecast = HoltWinters(logsouvenirTS)
souvenirTSforecast
souvenirTSforecast$SSE
plot(souvenirTSforecast)
souvenirTSforecast2 = forecast.HoltWinters(souvenirTSforecast, h = 48)
plot.forecast(souvenirTSforecast2)
acf(souvenirTSforecast2$residuals, lag.max=20)
Box.test(souvenirTSforecast2$residuals, lag=20, type="Ljung-Box")
# 22.5 ARIMA MODELS ####
# While in Exponential Smoothing, data series and erros depend on
# autocorrelation (tự tương quan) assumption, while ARIMA (Autoregressive Integrated)
# Moving Average - Trung bình động tự tương quan), autocorrelation is adjusted
# (1) Auto-regressive: lags of stationarized series in the forecasting equation
# (2) Moving Average: lags of the forecast errors
# (3) A time series which needs to be differenced to be made stationary is said to be
# an "Integrated" version of a stationary series
# 22.5.1 Differencing (Sai phân) ####
# ARIMA is used for data series in stationary time series (thời gian ổn đinh)
# meaning that mean, variance, correlation coefficient is constant in time
# With non-stationary time series, differencing is necessarily utilised
# nonseasonal ARIMAR(p, d, q),
# d - number of autogressive terms
# q - number of nonseasonal differences needed for stationarity
# p - number of lagged forecast errors in the prediction equation
dif.skirts = diff(ts.skirts, differences = 1)
plot.ts(dif.skirts)
# The series is unstable as mean changes in time
dif.skirts2 = diff(ts.skirts, differences = 2)
plot.ts(dif.skirts2)
# Mean is more stable
dif.kings = diff(ts.kings, difference = 1)
plot.ts(dif.kings)
# 22.5.2 Choosing ARIMA Models
# Autocorrelation is a correlation coefficient of Y(i) & Y(i+k)
# acf() - Autocorrelation: looks at the correlation between now and various points
# in the past
# pccf - Partial Autocorrelation: does the same, but "partials out" the other effects
# to get the unique contribution of each time-lag
acf(dif.kings, lag.max = 20, plot = T) # ARIMA(p,1,q)
pacf(dif.kings, lag.max = 20)
# Using Principle of Parsimony (Nguyên lí tiết kiệm)
# The best model involves both minimum amount of parameters & best description of data
# ARMA(3,0) - 2 parameters, ARMA(0,1) - 1 parameter [BEST], ARMA(p,q) - 2 parameters
# lagged values: one or more previous values
# Moving Average (MA Model) ####
# Focus on white noise Z(t), not Y(t)
# ARMA(0,1) is MA(1) with q(sai phân)
# Used for time series data that is dependent in a short time
# Simulation time series data with ARIMA(1,0,1), 1000 value with AR(p = 0.3) and
# MA(q = 0.6), only taking values from 201 to make sure the model stability
test.data = arima.sim(model = list(ar = 0.3, ma = 0.6), n = 1000, n.start = 200)
# Use auto.arima() to find the best model
library(forecast)
auto.arima(test.data)
# The model is quite good with ar1 = 0.33, ma1 = 0.56
auto.arima(kings) # ARIMA(0,1,1)
# The result is aligned with previous calculation using diff() & acf()
# Autoregression (AR Model) ####
# Current observed value Y(t) depends on previous value Y(t-1), Y(t-2),...
# volcanic dust veil index in the northern hemisphere,
# from 1500-1969 (original data from Hipel and Mcleod, 1994
vc = scan("http://robjhyndman.com/tsdldata/annual/dvi.dat", skip=1)
ts.vc = ts(vc,start=c(1500))
ar(ts.vc)
plot.ts(ts.vc)
# Random variations seem constant over time, then Addictive (mô hình cộng hưởng)
# can be appropriate. Dont have to calculate difference as sariance is independent
# over time
auto.arima(ts.vc) # ARIMA(1,0,2)
# However if we use BIC (Bayesian Information Criterion)
auto.arima(vc, ic = "bic") # ARIMA(2,0,0)
# 22.5.3 Prediction using ARIMA ####
arima1 = arima(ts.kings, order = c(0, 1, 1))
arima1
forecast1 = forecast.Arima(arima1, h = 5)
forecast1
plot(forecast1)
arima2 = arima(ts.vc, order = c(2, 0, 0))
arima2
forecast2 = forecast.Arima(arima2, h = 50)
forecast2
plot(forecast2)
# 22.1 DATA INPUT & PLOT ####
# The age of death of 42 successive kings of England starting with William the Conqueror
kings = scan("http://robjhyndman.com/tsdldata/misc/kings.dat", skip = 3)
install.packages("TTR")
source('/Volumes/LIFE/0. Data Science/Phân tích dữ liệu với R/Descriptive Statistic.R', echo=TRUE)
source('/Volumes/LIFE/0. Data Science/Phân tích dữ liệu với R/10. Linear Regression .R', encoding = 'UTF-8', echo=TRUE)
source('/Volumes/LIFE/0. Data Science/Phân tích dữ liệu với R/10. Linear Regression .R', encoding = 'UTF-8', echo=TRUE)
source('/Volumes/LIFE/0. Data Science/Phân tích dữ liệu với R/10. Linear Regression .R', encoding = 'UTF-8', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
library(MASS)
library(ISLR)
fix(Boston)
names(Boston)
View(Boston)
?Boston
str(Boston)
Summary(Boston)
summary(Boston)
plot(Boston)
boxplot(Boston)
attach(Boston)
boxplot(Boston, -"tax")
boxplot(Boston, -tax)
boxplot(Boston, -c("tax", "black")
boxplot(Boston, -c("tax", "black")
boxplot(crim)
View(crim, ptratio)
new = cbind(crim, ptratio)
View(new)
lm(crim ~ ptratio)
summary(lm(crim ~ ptratio))
summary(lm(log(crim) ~ ptratio))
boxplot(log(crim))
summary(lm(log(crim) ~ ptratio + chas))
boxplot(ptratio)
boxplot(lstat)
fix(Boston)
names(Boston)
lm.fit=lm(medv~lstat)
lm.fit=lm(medv~lstat,data=Boston)
coef(lm.fit)
confint(lm.fit)
predict(lm.fit,data.frame(lstat=(c(5,10,15))), interval="confidence")
predict(lm.fit,data.frame(lstat=(c(5,10,15))), interval="prediction")
plot(lstat,medv)
boxplot(medv)
boxplot(lstat)
plot(lstat,medv)
abline(lm.fit)
abline(lm.fit,lwd=3)
abline(lm.fit,lwd=3,col="red")
plot(lstat,medv,col="red")
plot(lstat,medv,pch=20)
plot(lstat,medv,pch="+")
plot(1:20,1:20,pch=1:20)
plot(lm.fit)
plot(predict(lm.fit), rstudent(lm.fit))
plot(hatvalues(lm.fit))
which.max(hatvalues(lm.fit))
lm.fit=lm(medv~lstat+age,data=Boston)
summary(lm.fit)
lm.fit1=lm(medv~.-age,data=Boston)
summary(lm.fit1)
lm.fit1=update(lm.fit, ~.-age)
summary(lm(medv~lstat*age,data=Boston))
pair(Boston)
pairs(Boston)
cor(medv, age)
lm.fit2=lm(medv~lstat+I(lstat^2))
summary(lm.fit2)
lm.fit=lm(medv~lstat)
anova(lm.fit,lm.fit2)
lm.fit5=lm(medv~poly(lstat,5))
summary(lm.fit5)
summary(lm(medv~log(rm),data=Boston))
n
n <- nPlot(Allocation ~ AN, data = long_data,
group = "Type", type = "lineChart")
n$chart(yDomain = sort(range(long_data$Allocation),
decreasing = T) )
n$chart(interpolate = "step-after")
n$xAxis(axisLabel = "Year")
n$yAxis(axisLabel = "Allocation")
n$chart(margin = list(left = 75))
n
long_data <- Budget %>% gather(Type, Allocation, -AN)
library(reshape2)
library(magrittr)  # Package for pipeline %>%
library(ggplot2)
library(devtools)
library(Rcpp)
library(rCharts)
library(dplyr)
library(tidyr)
Budget <- read.csv("~/Downloads/Budget.txt", header=FALSE, stringsAsFactors=FALSE)
setwd("~/Documents/3. DSTI/Stat & ML/Projects")
Budget <- read.csv("~/Downloads/Budget.txt", header=FALSE, stringsAsFactors=FALSE)
View(Budget)
View(Budget)
Budget <- read.csv("Budget.txt", header=FALSE, stringsAsFactors=FALSE)
View(Budget)
dim(Budget)
colnames(Budget) = c("AN", "PVP", "AGR", "CMI", "TRA", "LOG", "EDU", "ACS", "ANC", "DEF", "DET", "DIV")
View(Budget)
long_data <- Budget %>% gather(Type, Allocation, -AN)
View(long_data)
n <- nPlot(Allocation ~ AN, data = long_data,
group = "Type", type = "lineChart")
n$chart(yDomain = sort(range(long_data$Allocation),
decreasing = T) )
n$chart(interpolate = "step-after")
n$xAxis(axisLabel = "Year")
n$yAxis(axisLabel = "Allocation")
n$chart(margin = list(left = 75))
n
n$chart(yDomain = sort(range(long_data$Allocation),
decreasing = T) )
n$chart(interpolate = "step-after")
n$xAxis(axisLabel = "Year")
n$yAxis(axisLabel = "Allocation")
n$chart(margin = list(left = 75))
n
n <- nPlot(Allocation ~ AN, data = long_data,
group = "Type", type = "lineChart")
n$chart(yDomain = sort(range(long_data$Allocation),
decreasing = F) )
n$chart(interpolate = "step-after")
n$xAxis(axisLabel = "Year")
n$yAxis(axisLabel = "Allocation")
n$chart(margin = list(left = 75))
n
km.out=kmeans(Budget[,-1],3,nstart=20)
km=kmeans(Budget[,-1],3,nstart=20)
km
km=kmeans(Budget[,-1],3,nstart=50)
km
plot(km)
plot(Budget[,-1], col=(km$cluster+1),
main="K-Means Clustering Results with K=2",
xlab="", ylab="", pch=20, cex=2)
plot(Budget[,-1], col=(km$cluster+1),
main="K-Means Clustering Results with K=3",
xlab="", ylab="", pch=20, cex=2)
Budget[,-1]
km=kmeans(Budget[,-1],3,nstart=50)
plot(Budget[,-1], col=(km$cluster+1),
main="K-Means Clustering Results with K=3",
xlab="", ylab="", pch=20, cex=2)
km$cluster
plot(Budget[,-1], col=(km$cluster+1),
main="K-Means Clustering Results with K=3",
xlab="", ylab="", pch=20, cex=2)
plot(Budget[,-1], col=(km$cluster+1),
main="K-Means Clustering Results with K=3",
pch=20, cex=2)
set.seed(2)
x=matrix(rnorm(50*2), ncol=2)
x[1:25,1]=x[1:25,1]+3
x[1:25,2]=x[1:25,2]-4
x
km.out=kmeans(x,2,nstart=20)
km.out
km.out$cluster
plot(x, col=(km.out$cluster+1),
main="K-Means Clustering Results with K=2",
xlab="", ylab="", pch=20, cex=2)
plot(x, col=(km.out$cluster+1),
main="K-Means Clustering Results with K=2",
xlab="", ylab="", pch=20, cex=2)
plot(x, col=(km.out$cluster+1),
main="K-Means Clustering Results with K=2",
xlab="", ylab="", pch=20, cex=2)
km.out=kmeans(x,4,nstart=50)
km.out
plot(x, col=(km.out$cluster),
main="K-Means Clustering Results with K=3",
xlab="", ylab="", pch=20, cex=2)
plot(Budget[,-1], col=(km$cluster+1),
main="K-Means Clustering Results with K=3",
pch=20, cex=2)
install.packages('factominer')
install.packages('FactoMineR')
library(FactoMineR)
View(Olympic)
setwd("~/Documents/3. DSTI/Stat & ML/Code and data")
olympic = read.csv("olympic_2.txt", header = T ,sep = "\t")
View(olympic)
dim(Olympic)
dims(Olympic)
dim(Olympic)
View(Olympic)
dim(olympic)
?PCA
res = PCA(olympic[,1:10])
summary(res)
View(olympic)
names(pr.out)
names(prcomp())
res = PCA(olympic, quanti.sup=11) # quanli.sup
summary(res,nbelements=Inf)
dimdesc(res)
dimdesc(res, proba=0.2)
plot(res, cex=0.8, invisible="quali", title="individuals PCA Graph")
plot(res, cex=0.8, habillage="competition")
plotellipses(res)
plot(res, cex=0.8, invisible="quali", select=c('Clay','Karpov '))
plot(res, cex=0.8, invisible="quali", select='contrib 5')
plot(res, cex=0.8, invisible="quali", select='cos2 0.7')
plot(res, choix='var', select'contrib 5')
plot(res, choix='var', select='contrib 5')
plot(res, cex=0.8, habillage = 13, select='cos2 0.7', title="Decathlon",
cex.main=1.1, cex.axis=0.9, shadown=TRUE, auto='y')
plot(res, cex=0.8, habillage = 13, select='cos2 0.7', title="Decathlon",
cex.main=1.1, cex.axis=0.9, shadown=TRUE, auto='y')
plot(res, cex=0.8, habillage = 13, select='cos2 0.7', title="Decathlon",
cex.main=1.1, cex.axis=0.9, shadown=TRUE, auto='y')
plot(res, cex=0.8, habillage = 13, select='cos2 0.7', title="Decathlon",
cex.main=1.1, cex.axis=0.9, shadown=TRUE, auto='y')
plot( res, choix = 'ind', cex=0.8, habillage=11,
title = 'Individual PCA graph'), axes=3:4)
plot( res, choix = 'ind', cex=0.8, habillage=11,
title = 'Individual PCA graph', axes=3:4)
plot(res, choix='var', title='variables PCA graph', axes=3:4)
plot(res, cex=0.8, invisible="quali", select='cos2 0.7')
plot(res, cex=0.8, invisible="quali", select='contrib 5')
plot(res, cex=0.8, invisible="quali", select=c('Clay','Karpov '))
plot(res, choix='var', select='contrib 5')
plot(res, cex=0.8, habillage = 11, select='cos2 0.7', title="Decathlon",
cex.main=1.1, cex.axis=0.9, shadown=TRUE, auto='y')
plot(res, cex=0.8, habillage = 10, select='cos2 0.7', title="Decathlon",
cex.main=1.1, cex.axis=0.9, shadown=TRUE, auto='y')
plot(res, cex=0.8, select='cos2 0.7', title="Decathlon",
cex.main=1.1, cex.axis=0.9, shadown=TRUE, auto='y')
Budget <- read.csv("Budget.txt", header=FALSE, stringsAsFactors=FALSE)
View(Budget)
colnames(Budget) = c("AN", "PVP", "AGR", "CMI", "TRA", "LOG",
"EDU", "ACS", "ANC", "DEF", "DET", "DIV")
dim(Budget)
View(Budget)
res = PCA(Budget[,-1])
summary(res)
res
res = PCA(Budget[,-1])
budget = PCA(Budget[,-1])
summary(budget)
budget2 = princomp(Budget[,-1], cor = TRUE)
biplot(budget2)
View(Budget)
View(Budget)
View(Budget)
rownames(Budget[,1])
View(Budget)
rownames(Budget) = Budget[,1]
View(Budget)
budget = PCA(Budget[,-1])
budget2 = princomp(Budget[,-1], cor = TRUE)
biplot(budget2)
N<-matrix(rep(apply(Budget[,-1],2,sd),24), nrow=24)
N<- (24-1)/23*(1/N)
M<-matrix(rep(apply(Budget[,-1],2,mean),24),nrow=24)
Mprime<-Budget[,-1]-M
M_n<-Mprime*N
my_H_clust<-hclust(dist(M_n),method ="ward.D2")
plot(my_H_clust)
plot(my_H_clust$height)
lines(my_H_clust$height, col='green')
head(N)
method(hclust)
methods(hclust)
plot(my_H_clust)
plot(my_H_clust$height)
lines(my_H_clust$height, col='green')
lo <-smooth.spline(my_H_clust$height, spar=0.5)
le<-smooth.spline(my_H_clust$height, spar=0.5)
lo <-smooth.spline(my_H_clust$height, spar=0.5)
le<-smooth.spline(my_H_clust$height, spar=0.5)
plot(my_H_clust$height)
lines(predict(lo, deriv=1), col='red')
lines(predict(le), col='blue')
x<-c(1,20)
y<-c(13,9)
#plot(x,y)
#lines(x,y, col=2)
my_h <-rev(my_H_clust$height)
my_h<-round(my_h,2)
plot(my_h, type='n')
#text(my_h,labels= my_h)
lines(my_h, col='green')
lines(x=c(48.11,36.24,24,12,0),col='red')
text(my_h,labels=my_h,cex=0.5)
lines(x,y, col=2)
Lambda_r<-(P$sdev)^2/sum((P$sdev)^2)
plot(Lambda_r, col='green')
lines(Lambda_r, col='pink')
Lambda_r<-cumsum(Lambda_r)
plot(Lambda_r)
lines(Lambda_r,col='pink')
abline(h = 0.9,col='black')
abline(h = 0.8,col='red')
P = princomp(Budget[,-1], cor=T)
Lambda_r<-(P$sdev)^2/sum((P$sdev)^2)
plot(Lambda_r, col='green')
lines(Lambda_r, col='pink')
Lambda_r<-cumsum(Lambda_r)
plot(Lambda_r)
lines(Lambda_r,col='pink')
abline(h = 0.9,col='black')
abline(h = 0.8,col='red')
message("3 values have been replaced")
budget2 = princomp(Budget[,-1], cor = TRUE)
budget = PCA(Budget[,-1])
summary(budget)
plot( res, choix = 'ind', cex=0.8, habillage=11,
title = 'Individual PCA graph', axes=3:4)
plot( res, choix = 'ind', cex=0.8,
title = 'Individual PCA graph', axes=3:4)
screeplot(PCA,type='lines',col=3)
screeplot(budget,type='lines',col=3)
screeplot(budget2,type='lines',col=3)
budget
summary(PCA)
plot(budget, choix='var', title='variables PCA graph', axes=2:3)
plot(budget, choix='ind', title='variables PCA graph', axes=2:3)
X11
X11()
plot(budget, choix='ind', title='ind PCA graph', axes=1:2)
X11()
plot(budget, choix='ind', title='ind PCA graph', axes=1:3)
plot(budget, choix='ind', title='ind PCA graph', axes=1:2)
X11()
plot(budget, choix='ind', title='ind PCA graph', axes=1:3)
plot(budget, choix='ind', title='ind PCA graph', axes=1:3)
plot(budget, choix='ind', title='ind PCA graph', axes=1:2)
plot(budget, choix='ind', title='ind PCA graph', axes=1:3)
plot(budget, choix='ind', title='ind PCA graph', axes=2:3)
plot(budget, choix='ind', title='ind PCA graph', axes=1:4)
plot(budget, choix='ind', title='ind PCA graph', axes=2:3)
plot(budget, choix='ind', title='ind PCA graph', axes=3:1)
plot(budget, choix='ind', title='ind PCA graph', axes=1:2)
plot(budget, choix='ind', title='ind PCA graph', axes=3:1)
plot(budget, choix='ind', title='ind PCA graph', axes=1:3)
plot(budget, choix='ind', title='ind PCA graph', axes=c(1:3))
plot(budget, choix='ind', title='ind PCA graph', axes=c(1:2))
plot(budget, choix='ind', title='ind PCA graph', axes=c(1,3))
long_data <- Budget %>% gather(Type, Allocation, -AN)
View(long_data)
n <- nPlot(Allocation ~ AN, data = long_data,
group = "Type", type = "lineChart")
n$chart(yDomain = sort(range(long_data$Allocation),
decreasing = F) )
n$chart(interpolate = "step-after")
n$xAxis(axisLabel = "Year")
n$yAxis(axisLabel = "Allocation")
n$chart(margin = list(left = 75))
n
plot(budget, choix='var', title='var PCA graph', axes=c(1:2))
plot(res, choix='var', title='variables PCA graph', axes=c(1,3))
plot(res, choix='var', title='variables PCA graph', axes=c(2,3))
Budget[,2]
par(mfrow = c(3,4))
for (i in 2:(ncol(Budget))) {
tb = ts(Budget[,i])
plot(tb)
}
View(Budget)
km=kmeans(Budget[,-1],3,nstart=50)
Budget[,-1]
km$cluster
plot(Budget[,-1], col=(km$cluster+1),
main="K-Means Clustering Results with K=3",
pch=20, cex=2)
km=kmeans(Budget[,-1],3,nstart=50)
Budget[,-1]
km$cluster
plot(Budget[,-1], col=(km$cluster+1),
main="K-Means Clustering Results with K=3",
pch=20, cex=2)
names(km)
class(km$cluster)
plot(Budget[,1],km$cluster)
plot(my_H_clust)
par(mfrow=c(1,1))
plot(my_H_clust)
my_H_clust1 = hclust(dist(M_n), method='complete')
plot(my_H_clust1)
